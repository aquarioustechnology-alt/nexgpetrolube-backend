generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String         @id @default(cuid())
  email           String         @unique
  phone           String?
  firstName       String?
  lastName        String?
  companyName     String
  role            UserRole       @default(BUYER)
  kycStatus       KycStatus      @default(PENDING)
  isActive        Boolean        @default(true)
  isEmailVerified Boolean        @default(false)
  isPhoneVerified Boolean        @default(false)
  profileImage    String?
  password        String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  addresses       Address[]
  bankDetails     BankDetail?
  bids            Bid[]
  kyc             Kyc?
  listings        Listing[]
  notifications   Notification[]
  quotes          Quote[]
  requirements    Requirement[]
  wishlist        WishlistItem[]
  offers          Offer[]           @relation("UserOffers")
  requirementOwnerOffers Offer[]    @relation("RequirementOwnerOffers")
  offerHistory    OfferHistory[]    @relation("UserOfferHistory")
  offerNotifications OfferNotification[] @relation("UserOfferNotifications")
  counterOffers   CounterOffer[]    @relation("UserCounterOffers")
  payments        Payment[]
  logistics       Logistics[]

  @@map("users")
}

model OtpVerification {
  id        String   @id @default(cuid())
  email     String   @unique
  phone     String?
  otp       String
  attempts  Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("otp_verifications")
}

model Address {
  id        String   @id @default(cuid())
  userId    String
  type      String
  line1     String
  line2     String?
  city      String
  state     String
  country   String   @default("India")
  pincode   String
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("addresses")
}

model Kyc {
  id              String        @id @default(cuid())
  userId          String        @unique
  panNumber       String?
  aadhaarNumber   String?
  gstNumber       String?
  yearsInBusiness Int?
  kycStatus       KycStatus     @default(PENDING)
  rejectionReason String?
  reviewedBy      String?
  reviewedAt      DateTime?
  submittedAt     DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents       KycDocument[]

  @@map("kyc")
}

model KycDocument {
  id         String   @id @default(cuid())
  kycId      String
  type       String
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String
  isVerified Boolean  @default(false)
  uploadedAt DateTime @default(now())
  kyc        Kyc      @relation(fields: [kycId], references: [id], onDelete: Cascade)

  @@map("kyc_documents")
}

model BankDetail {
  id                String   @id @default(cuid())
  userId            String   @unique
  accountNumber     String
  ifscCode          String
  bankName          String
  accountHolderName String
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("bank_details")
}

model Category {
  id            String        @id @default(cuid())
  name          String        @unique
  description   String?
  parentId      String?
  isActive      Boolean       @default(true)
  sortOrder     Int           @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  parent        Category?     @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      Category[]    @relation("CategoryHierarchy")
  listings      Listing[]
  products      Product[]
  requirements  Requirement[] @relation("RequirementCategory")
  subcategories Subcategory[]
  productSubcategories Product[] @relation("ProductSubcategory")
  requirementSubcategories Requirement[] @relation("RequirementSubcategory")

  @@map("categories")
}

model Subcategory {
  id           String        @id @default(cuid())
  name         String
  description  String?
  categoryId   String
  isActive     Boolean       @default(true)
  sortOrder    Int           @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  listings     Listing[]
  category     Category      @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@map("subcategories")
}

model Brand {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?
  logo        String?
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  listings    Listing[]
  products    Product[]
  requirements Requirement[]

  @@map("brands")
}

model Unit {
  id           String   @id @default(cuid())
  name         String   @unique
  symbol       String   @unique
  description  String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  listings     Listing[]

  @@map("units")
}

model Product {
  id             String        @id @default(cuid())
  name           String
  description    String?
  keyFeatures    String?
  specifications Json?
  images         String[]      @default([])
  categoryId     String
  subcategoryId  String?
  brandId        String?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  brand          Brand?        @relation(fields: [brandId], references: [id])
  category       Category      @relation(fields: [categoryId], references: [id])
  subcategory    Category?     @relation("ProductSubcategory", fields: [subcategoryId], references: [id])
  requirements   Requirement[]

  @@map("products")
}

model Listing {
  id              String         @id @default(cuid())
  userId          String
  title           String
  description     String
  categoryId      String
  subcategoryId   String?
  brandId         String?
  unitId          String
  listingType     ListingType
  basePrice       Decimal
  moq             String
  quantity        Decimal?
  specifications  Json?
  images          String[]
  status          ListingStatus  @default(PENDING)
  isActive        Boolean        @default(true)
  views           Int            @default(0)
  submittedAt     DateTime       @default(now())
  approvedAt      DateTime?
  approvedBy      String?
  rejectionReason String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  auctions        Auction[]
  brand           Brand?         @relation(fields: [brandId], references: [id])
  category        Category       @relation(fields: [categoryId], references: [id])
  subcategory     Subcategory?   @relation(fields: [subcategoryId], references: [id])
  unit            Unit           @relation(fields: [unitId], references: [id])
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  wishlist        WishlistItem[]

  @@map("listings")
}

model Requirement {
  id               String             @id @default(cuid())
  userId           String
  userType         UserRole
  title            String
  description      String
  shortDescription String?
  additionalNotes  String?
  categoryId       String
  subcategoryId    String?
  productId        String?
  productName      String?
  brandId          String?
  brandName        String?
  quantity         String?
  availableQuantity String?
  units            String?
  unitPrice        String?
  postingType      PostingType        @default(REQUIREMENT)
  negotiableType   String?
  negotiationWindow String?
  urgency          RequirementUrgency @default(MEDIUM)
  status           RequirementStatus  @default(OPEN)
  deliveryMethod   String
  deliveryTimeline String
  country          String             @default("India")
  city             String?
  state            String?
  technicalSpecs   Json?
  images           String[]
  visibility       String             @default("public")
  visibilityType   String?
  visibleEmails    String[]           @default([])
  visibleState     String?
  visibleCity      String?
  quotesCount      Int                @default(0)
  deadline         DateTime?
  postedAt         DateTime           @default(now())
  // Admin approval fields
  adminStatus      RequirementStatus? @default(PENDING)
  approvedBy       String?
  approvedAt       DateTime?
  rejectedBy       String?
  rejectedAt       DateTime?
  rejectionReason  String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  auctions         Auction[]
  quotes           Quote[]
  offers           Offer[]            @relation("RequirementOffers")
  counterOffers    CounterOffer[]     @relation("RequirementCounterOffers")
  category         Category           @relation("RequirementCategory", fields: [categoryId], references: [id])
  subcategory      Category?          @relation("RequirementSubcategory", fields: [subcategoryId], references: [id])
  product          Product?           @relation(fields: [productId], references: [id])
  brand            Brand?             @relation(fields: [brandId], references: [id])
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("requirements")
}

model Auction {
  id                  String        @id @default(cuid())
  type                AuctionType
  title               String
  description         String
  listingId           String?
  requirementId       String?
  totalQuantity       Decimal
  filledQuantity      Decimal       @default(0)
  startPrice          Decimal?
  reservePrice        Decimal?
  currentBid          Decimal?
  minimumBidIncrement Decimal?
  startTime           DateTime
  endTime             DateTime
  status              AuctionStatus @default(SCHEDULED)
  biddersCount        Int           @default(0)
  isH1H2SplitEnabled  Boolean       @default(false)
  h1H2SplitRatio      Decimal?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  listing             Listing?      @relation(fields: [listingId], references: [id])
  requirement         Requirement?  @relation(fields: [requirementId], references: [id])
  bids                Bid[]

  @@map("auctions")
}

model Bid {
  id        String    @id @default(cuid())
  auctionId String
  userId    String
  amount    Decimal
  quantity  Decimal?
  status    BidStatus @default(ACTIVE)
  isWinning Boolean   @default(false)
  placedAt  DateTime  @default(now())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  auction   Auction   @relation(fields: [auctionId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("bids")
}

model Quote {
  id            String      @id @default(cuid())
  requirementId String
  userId        String
  amount        Decimal
  quantity      String
  description   String?
  status        QuoteStatus @default(PENDING)
  validUntil    DateTime?
  submittedAt   DateTime    @default(now())
  respondedAt   DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  requirement   Requirement @relation(fields: [requirementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("quotes")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model WishlistItem {
  id        String   @id @default(cuid())
  userId    String
  listingId String
  createdAt DateTime @default(now())
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
  @@map("wishlist_items")
}

model AdminUser {
  id          String    @id @default(cuid())
  email       String    @unique
  firstName   String
  lastName    String
  password    String
  role        AdminRole
  isActive    Boolean   @default(true)
  lastLoginAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("admin_users")
}

model AuditLog {
  id        String   @id @default(cuid())
  adminId   String?
  userId    String?
  action    String
  entity    String
  entityId  String?
  oldData   Json?
  newData   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@map("audit_logs")
}

model CommissionRule {
  id            String    @id @default(cuid())
  name          String
  categoryId    String?
  subcategoryId String?
  brandId       String?
  percentage    Decimal
  fixedAmount   Decimal?
  minAmount     Decimal?
  maxAmount     Decimal?
  isActive      Boolean   @default(true)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("commission_rules")
}

model Invoice {
  id            String    @id @default(cuid())
  invoiceNumber String    @unique
  userId        String
  amount        Decimal
  commission    Decimal
  status        String
  dueDate       DateTime
  paidAt        DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("invoices")
}

model ChatRoom {
  id           String                @id @default(cuid())
  name         String?
  type         String
  entityId     String?
  isActive     Boolean               @default(true)
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  messages     ChatMessage[]
  participants ChatRoomParticipant[]

  @@map("chat_rooms")
}

model ChatRoomParticipant {
  id       String    @id @default(cuid())
  roomId   String
  userId   String
  joinedAt DateTime  @default(now())
  leftAt   DateTime?
  room     ChatRoom  @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@map("chat_room_participants")
}

model ChatMessage {
  id        String   @id @default(cuid())
  roomId    String
  userId    String
  message   String
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  room      ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

enum UserRole {
  BUYER
  SELLER
  BOTH
  ADMIN
}

enum KycStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  REJECTED
}

enum ListingType {
  FIXED
  NEGOTIATION
  BIDDING
}

enum ListingStatus {
  PENDING
  APPROVED
  REJECTED
  DRAFT
}

enum RequirementStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  OPEN
  QUOTED
  CLOSED
  CANCELLED
}

enum RequirementUrgency {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum PostingType {
  REQUIREMENT
  REVERSE_BIDDING
  STANDARD_BIDDING
}

enum AuctionType {
  REVERSE
  TRADITIONAL
}

enum AuctionStatus {
  SCHEDULED
  LIVE
  PAUSED
  ENDED
  CANCELLED
}

enum BidStatus {
  ACTIVE
  OUTBID
  WINNING
  WON
  LOST
}

enum QuoteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum NotificationType {
  BID_UPDATE
  QUOTE_RECEIVED
  AUCTION_ENDING
  KYC_STATUS
  SYSTEM_ALERT
  LISTING_APPROVED
  LISTING_REJECTED
  REQUIREMENT_QUOTED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
}

model Offer {
  id                   String           @id @default(cuid())
  requirementId        String
  requirementOwnerType UserRole
  offeredUnitPrice     Decimal          @db.Decimal(10, 2)
  offeredQuantity      String
  requirementOwnerId   String
  offerUserId          String
  negotiableType       String
  postingType          PostingType
  negotiationWindow    Int?             // Negotiation window in hours
  deadline             DateTime?
  offerStatus          OfferStatus       @default(PENDING)
  offerMessage         String?           @db.Text
  parentOfferId        String?
  offerExpiryDate      DateTime?
  minimumQuantity      String?
  maximumQuantity      String?
  deliveryTerms        String?           @db.Text
  paymentTerms         String?           @db.Text
  validityPeriod       Int?              // Offer validity period in days
  isCounterOffer       Boolean           @default(false)
  offerPriority        OfferPriority      @default(MEDIUM)
  // Counteroffer fields
  counterofferCount    Int               @default(0)
  originalPrice        Decimal?           @db.Decimal(10, 2)
  originalQuantity     String?
  // Payment success fields
  sellerPaymentStatus  PaymentStatus     @default(PENDING)
  buyerPaymentStatus   PaymentStatus     @default(PENDING)
  sellerPaymentId      String?
  buyerPaymentId       String?
  sellerPaidAt         DateTime?
  buyerPaidAt          DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  deletedAt            DateTime?

  // Relations
  requirement          Requirement       @relation("RequirementOffers", fields: [requirementId], references: [id], onDelete: Cascade)
  requirementOwner     User              @relation("RequirementOwnerOffers", fields: [requirementOwnerId], references: [id], onDelete: Cascade)
  offerUser            User              @relation("UserOffers", fields: [offerUserId], references: [id], onDelete: Cascade)
  parentOffer           Offer?            @relation("CounterOffers", fields: [parentOfferId], references: [id], onDelete: SetNull)
  counterOffers         Offer[]           @relation("CounterOffers")
  counterOffersList     CounterOffer[]    @relation("OfferCounterOffers")
  offerHistory          OfferHistory[]
  offerNotifications    OfferNotification[]
  sellerPayment        Payment?          @relation("OfferSellerPayment", fields: [sellerPaymentId], references: [id], onDelete: SetNull)
  buyerPayment         Payment?          @relation("OfferBuyerPayment", fields: [buyerPaymentId], references: [id], onDelete: SetNull)
  logistics            Logistics[]

  @@map("offers")
}

model CounterOffer {
  id                   String           @id @default(cuid())
  offerId              String
  fromId               String
  requirementId        String
  counterofferNumber   Int              // 1, 2, 3, 4, 5 (max 5)
  offeredPrice         Decimal          @db.Decimal(10, 2)
  offeredQuantity      String
  status               CounterOfferStatus @default(PENDING)
  negotiationWindowHours Int            // Hours from requirement
  expiresAt            DateTime
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Relations
  offer                Offer            @relation("OfferCounterOffers", fields: [offerId], references: [id], onDelete: Cascade)
  fromUser             User             @relation("UserCounterOffers", fields: [fromId], references: [id], onDelete: Cascade)
  requirement          Requirement      @relation("RequirementCounterOffers", fields: [requirementId], references: [id], onDelete: Cascade)

  @@map("counter_offers")
}

enum CounterOfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model OfferHistory {
  id          String         @id @default(cuid())
  offerId     String
  action      OfferAction
  performedBy String
  performedAt DateTime       @default(now())
  notes       String?        @db.Text
  oldValues   Json?
  newValues   Json?

  // Relations
  offer       Offer          @relation(fields: [offerId], references: [id], onDelete: Cascade)
  performer   User           @relation("UserOfferHistory", fields: [performedBy], references: [id], onDelete: Cascade)

  @@map("offer_history")
}

model OfferNotification {
  id               String             @id @default(cuid())
  offerId          String
  recipientId      String
  notificationType OfferNotificationType
  isRead           Boolean            @default(false)
  createdAt        DateTime           @default(now())

  // Relations
  offer            Offer              @relation(fields: [offerId], references: [id], onDelete: Cascade)
  recipient        User               @relation("UserOfferNotifications", fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("offer_notifications")
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
  WITHDRAWN
  COUNTERED
}

enum OfferAction {
  CREATED
  UPDATED
  ACCEPTED
  REJECTED
  EXPIRED
  WITHDRAWN
  COUNTERED
}

enum OfferNotificationType {
  NEW_OFFER
  OFFER_ACCEPTED
  OFFER_REJECTED
  OFFER_EXPIRED
  COUNTER_OFFER
}

enum OfferPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum UnitType {
  LITERS
  KILOGRAMS
  TONS
  PIECES
  CARTONS
  DRUMS
  BARRELS
  CUBIC_METERS
  SQUARE_METERS
  METERS
  FEET
  INCHES
  GALLONS
  POUNDS
  OUNCES
  GRAMS
  MILLILITERS
  CUBIC_FEET
  SQUARE_FEET
  YARDS
  CUSTOM
}

enum AdminRole {
  SUPER_ADMIN
  COMPLIANCE
  MODERATOR
  FINANCE
  CMS_EDITOR
  SUPPORT
}

model Payment {
  id                String        @id @default(cuid())
  offerId           String?       // Optional - can be used for other payment types
  userId            String        // User making the payment
  paymentType       PaymentType
  amount            Decimal       @db.Decimal(10, 2)
  currency          String        @default("INR")
  paymentMethod     PaymentMethod
  paymentStatus     PaymentStatus @default(PENDING)
  transactionId     String?       // External payment gateway transaction ID
  gatewayResponse   Json?         // Store gateway response data
  utrNumber         String?       // UTR number for bank transfers
  paymentScreenshot String?       // Screenshot of payment proof
  notes             String?       @db.Text
  processedAt       DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  sellerOffers      Offer[]       @relation("OfferSellerPayment")
  buyerOffers       Offer[]       @relation("OfferBuyerPayment")

  @@map("payments")
}

model Logistics {
  id                String           @id @default(cuid())
  offerId           String           // Required - logistics is always tied to an offer
  userId            String           // User who created the logistics entry
  driverName        String?
  driverPhone       String?
  truckNumber       String?
  truckType         String?
  logisticsCompany  String?
  companyPhone      String?
  companyEmail      String?
  pickupAddress     String?          @db.Text
  deliveryAddress   String?          @db.Text
  estimatedPickupDate   DateTime?
  estimatedDeliveryDate DateTime?
  actualPickupDate     DateTime?
  actualDeliveryDate   DateTime?
  status            LogisticsStatus   @default(PENDING)
  notes             String?          @db.Text
  trackingNumber    String?
  // New fields
  invoiceCopy       String?          // File path for invoice copy
  biltyCopy         String?          // File path for bilty copy
  insurance         Boolean?         // Insurance yes/no
  trackingId        String?          // Any tracking ID
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  offer             Offer            @relation(fields: [offerId], references: [id], onDelete: Cascade)
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("logistics")
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum PaymentType {
  COMMISSION
  COMPLETE_PAYMENT
  REFUND
  ADVANCE_PAYMENT
}

enum PaymentMethod {
  UPI
  CARD
  NET_BANKING
  WALLET
  BANK_TRANSFER
}

enum LogisticsStatus {
  PENDING
  SCHEDULED
  IN_TRANSIT
  DELIVERED
  CANCELLED
}
