generator client {
  provider = "prisma-client-js"
  log      = ["error", "warn"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String         @id @default(cuid())
  email           String         @unique
  phone           String?
  firstName       String?
  lastName        String?
  companyName     String
  role            UserRole       @default(BUYER)
  kycStatus       KycStatus      @default(PENDING)
  isActive        Boolean        @default(true)
  isEmailVerified Boolean        @default(false)
  isPhoneVerified Boolean        @default(false)
  profileImage    String?
  password        String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  addresses       Address[]
  bankDetails     BankDetail?
  requirementOwnerBids Bid[]           @relation("RequirementOwnerBids")
  userBids            Bid[]           @relation("UserBids")
  kyc             Kyc?
  notifications   Notification[]
  requirements    Requirement[]
  wishlist        WishlistItem[]
  offers          Offer[]           @relation("UserOffers")
  requirementOwnerOffers Offer[]    @relation("RequirementOwnerOffers")
  offerHistory    OfferHistory[]    @relation("UserOfferHistory")
  offerNotifications OfferNotification[] @relation("UserOfferNotifications")
  counterOffers   CounterOffer[]    @relation("UserCounterOffers")
  payments        Payment[]
  logistics       Logistics[]

  @@map("users")
}

model OtpVerification {
  id        String   @id @default(cuid())
  email     String   @unique
  phone     String?
  otp       String
  attempts  Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("otp_verifications")
}

model Address {
  id        String   @id @default(cuid())
  userId    String
  type      String
  line1     String
  line2     String?
  city      String
  state     String
  country   String   @default("India")
  pincode   String
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("addresses")
}

model Kyc {
  id              String        @id @default(cuid())
  userId          String        @unique
  panNumber       String?
  aadhaarNumber   String?
  gstNumber       String?
  yearsInBusiness Int?
  kycStatus       KycStatus     @default(PENDING)
  rejectionReason String?
  reviewedBy      String?
  reviewedAt      DateTime?
  submittedAt     DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents       KycDocument[]

  @@map("kyc")
}

model KycDocument {
  id         String   @id @default(cuid())
  kycId      String
  type       String
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String
  isVerified Boolean  @default(false)
  uploadedAt DateTime @default(now())
  kyc        Kyc      @relation(fields: [kycId], references: [id], onDelete: Cascade)

  @@map("kyc_documents")
}

model BankDetail {
  id                String   @id @default(cuid())
  userId            String   @unique
  accountNumber     String
  ifscCode          String
  bankName          String
  accountHolderName String
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("bank_details")
}

model Category {
  id            String        @id @default(cuid())
  name          String        @unique
  description   String?
  parentId      String?
  isActive      Boolean       @default(true)
  sortOrder     Int           @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  parent        Category?     @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      Category[]    @relation("CategoryHierarchy")
  products      Product[]
  requirements  Requirement[] @relation("RequirementCategory")
  productSubcategories Product[] @relation("ProductSubcategory")
  requirementSubcategories Requirement[] @relation("RequirementSubcategory")

  @@map("categories")
}


model Brand {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?
  logo        String?
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  products    Product[]
  requirements Requirement[]

  @@map("brands")
}

model Unit {
  id           String   @id @default(cuid())
  name         String   @unique
  symbol       String   @unique
  description  String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("units")
}

model Product {
  id             String        @id @default(cuid())
  name           String
  description    String?
  keyFeatures    String?
  specifications Json?
  images         String[]      @default([])
  categoryId     String
  subcategoryId  String?
  brandId        String?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  brand          Brand?        @relation(fields: [brandId], references: [id])
  category       Category      @relation(fields: [categoryId], references: [id])
  subcategory    Category?     @relation("ProductSubcategory", fields: [subcategoryId], references: [id])
  requirements   Requirement[]

  @@map("products")
}


model Requirement {
  id               String             @id @default(cuid())
  userId           String
  userType         UserRole
  title            String
  description      String
  shortDescription String?
  additionalNotes  String?
  categoryId       String
  subcategoryId    String?
  productId        String?
  productName      String?
  brandId          String?
  brandName        String?
  quantity         String?
  availableQuantity String?
  units            String?
  unitPrice        String?
  postingType      PostingType        @default(REQUIREMENT)
  negotiableType   String?
  negotiationWindow String?
  urgency          RequirementUrgency @default(MEDIUM)
  status           RequirementStatus  @default(OPEN)
  deliveryMethod   String
  deliveryTimeline String
  country          String             @default("India")
  city             String?
  state            String?
  technicalSpecs   Json?
  images           String[]
  visibility       String             @default("public")
  visibilityType   String?
  visibleEmails    String[]           @default([])
  visibleState     String?
  visibleCity      String?
  quotesCount      Int                @default(0)
  deadline         DateTime?
  postedAt         DateTime           @default(now())
  // Bidding-specific fields
  biddingStartDate String?
  biddingStartTime String?
  biddingEndDate   String?
  biddingEndTime   String?
  minimumBidDecrement String?
  enableH1H2Split  Boolean            @default(false)
  h1H2SplitRatio  String?
  reservePrice     String?
  // Add bidding status fields
  biddingStatus    RequirementStatus? // LIVE, ENDED, PAUSED for bidding
  currentBid       Decimal?            // Current highest bid
  biddersCount     Int                @default(0) // Number of bidders
  // Admin approval fields
  adminStatus      RequirementStatus? @default(PENDING)
  approvedBy       String?
  approvedAt       DateTime?
  rejectedBy       String?
  rejectedAt       DateTime?
  rejectionReason  String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  bids             Bid[]              @relation("RequirementBids")
  offers           Offer[]            @relation("RequirementOffers")
  counterOffers    CounterOffer[]     @relation("RequirementCounterOffers")
  wishlist         WishlistItem[]
  category         Category           @relation("RequirementCategory", fields: [categoryId], references: [id])
  subcategory      Category?          @relation("RequirementSubcategory", fields: [subcategoryId], references: [id])
  product          Product?           @relation(fields: [productId], references: [id])
  brand            Brand?             @relation(fields: [brandId], references: [id])
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("requirements")
}


model Bid {
  id                   String           @id @default(cuid())
  requirementId        String
  requirementOwnerType UserRole
  offeredUnitPrice     Decimal          @db.Decimal(10, 2)
  offeredQuantity      String
  requirementOwnerId   String
  bidUserId            String
  negotiableType       String
  postingType          PostingType
  negotiationWindow    Int?             // Negotiation window in hours
  deadline             DateTime?
  bidStatus            BidStatus        @default(ACTIVE)
  bidMessage           String?          @db.Text
  parentBidId          String?
  bidExpiryDate        DateTime?
  minimumQuantity      String?
  maximumQuantity      String?
  deliveryTerms        String?          @db.Text
  paymentTerms         String?          @db.Text
  validityPeriod       Int?             // Bid validity period in days
  isCounterBid         Boolean          @default(false)
  bidPriority          OfferPriority    @default(MEDIUM)
  // Counterbid fields
  counterbidCount      Int              @default(0)
  originalPrice        Decimal?          @db.Decimal(10, 2)
  originalQuantity     String?
  // Payment success fields
  sellerPaymentStatus  PaymentStatus    @default(PENDING)
  buyerPaymentStatus   PaymentStatus    @default(PENDING)
  sellerPaymentId      String?
  buyerPaymentId       String?
  sellerPaidAt         DateTime?
  buyerPaidAt          DateTime?
  // Allocation fields for multi-supplier scenarios
  allocatedQuantity    Int?             // Allocated quantity based on percentage
  allocatedPercentage  Decimal?         @db.Decimal(5, 2) // Allocation percentage (0-100)
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  deletedAt            DateTime?

  // Relations
  requirement          Requirement      @relation("RequirementBids", fields: [requirementId], references: [id], onDelete: Cascade)
  requirementOwner     User             @relation("RequirementOwnerBids", fields: [requirementOwnerId], references: [id], onDelete: Cascade)
  bidUser              User             @relation("UserBids", fields: [bidUserId], references: [id], onDelete: Cascade)
  parentBid            Bid?             @relation("CounterBids", fields: [parentBidId], references: [id], onDelete: SetNull)
  counterBids          Bid[]            @relation("CounterBids")
  sellerPayment        Payment?         @relation("BidSellerPayment", fields: [sellerPaymentId], references: [id], onDelete: SetNull)
  buyerPayment         Payment?         @relation("BidBuyerPayment", fields: [buyerPaymentId], references: [id], onDelete: SetNull)
  payments             Payment[]        @relation("BidPayments")
  logistics            Logistics[]      @relation("BidLogistics")

  @@map("bids")
}


model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model WishlistItem {
  id             String       @id @default(cuid())
  userId         String
  requirementId  String
  createdAt      DateTime     @default(now())
  requirement    Requirement  @relation(fields: [requirementId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, requirementId])
  @@map("wishlist_items")
}

model AdminUser {
  id          String    @id @default(cuid())
  email       String    @unique
  firstName   String
  lastName    String
  password    String
  role        AdminRole
  isActive    Boolean   @default(true)
  lastLoginAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("admin_users")
}

model AuditLog {
  id        String   @id @default(cuid())
  adminId   String?
  userId    String?
  action    String
  entity    String
  entityId  String?
  oldData   Json?
  newData   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@map("audit_logs")
}

model CommissionRule {
  id            String    @id @default(cuid())
  name          String
  categoryId    String?
  subcategoryId String?
  brandId       String?
  percentage    Decimal
  fixedAmount   Decimal?
  minAmount     Decimal?
  maxAmount     Decimal?
  isActive      Boolean   @default(true)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("commission_rules")
}

model Invoice {
  id            String    @id @default(cuid())
  invoiceNumber String    @unique
  userId        String
  amount        Decimal
  commission    Decimal
  status        String
  dueDate       DateTime
  paidAt        DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("invoices")
}

model ChatRoom {
  id           String                @id @default(cuid())
  name         String?
  type         String
  entityId     String?
  isActive     Boolean               @default(true)
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  messages     ChatMessage[]
  participants ChatRoomParticipant[]

  @@map("chat_rooms")
}

model ChatRoomParticipant {
  id       String    @id @default(cuid())
  roomId   String
  userId   String
  joinedAt DateTime  @default(now())
  leftAt   DateTime?
  room     ChatRoom  @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@map("chat_room_participants")
}

model ChatMessage {
  id        String   @id @default(cuid())
  roomId    String
  userId    String
  message   String
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  room      ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

enum UserRole {
  BUYER
  SELLER
  BOTH
  ADMIN
}

enum KycStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  REJECTED
}


enum RequirementStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  OPEN
  QUOTED
  CLOSED
  CANCELLED
  LIVE      // Add this for bidding status
  ENDED     // Add this for bidding status
  PAUSED    // Add this for bidding status
}

enum RequirementUrgency {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum PostingType {
  REQUIREMENT
  REVERSE_BIDDING
  STANDARD_BIDDING
}


enum BidStatus {
  ACTIVE
  OUTBID
  WINNING
  WON
  LOST
}


enum NotificationType {
  BID_UPDATE
  QUOTE_RECEIVED
  AUCTION_ENDING
  KYC_STATUS
  SYSTEM_ALERT
  LISTING_APPROVED
  LISTING_REJECTED
  REQUIREMENT_QUOTED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
}

model Offer {
  id                   String           @id @default(cuid())
  requirementId        String
  requirementOwnerType UserRole
  offeredUnitPrice     Decimal          @db.Decimal(10, 2)
  offeredQuantity      String
  requirementOwnerId   String
  offerUserId          String
  negotiableType       String
  postingType          PostingType
  negotiationWindow    Int?             // Negotiation window in hours
  deadline             DateTime?
  offerStatus          OfferStatus       @default(PENDING)
  offerMessage         String?           @db.Text
  parentOfferId        String?
  offerExpiryDate      DateTime?
  minimumQuantity      String?
  maximumQuantity      String?
  deliveryTerms        String?           @db.Text
  paymentTerms         String?           @db.Text
  validityPeriod       Int?              // Offer validity period in days
  isCounterOffer       Boolean           @default(false)
  offerPriority        OfferPriority      @default(MEDIUM)
  // Counteroffer fields
  counterofferCount    Int               @default(0)
  originalPrice        Decimal?           @db.Decimal(10, 2)
  originalQuantity     String?
  // Payment success fields
  sellerPaymentStatus  PaymentStatus     @default(PENDING)
  buyerPaymentStatus   PaymentStatus     @default(PENDING)
  sellerPaymentId      String?
  buyerPaymentId       String?
  sellerPaidAt         DateTime?
  buyerPaidAt          DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  deletedAt            DateTime?

  // Relations
  requirement          Requirement       @relation("RequirementOffers", fields: [requirementId], references: [id], onDelete: Cascade)
  requirementOwner     User              @relation("RequirementOwnerOffers", fields: [requirementOwnerId], references: [id], onDelete: Cascade)
  offerUser            User              @relation("UserOffers", fields: [offerUserId], references: [id], onDelete: Cascade)
  parentOffer           Offer?            @relation("CounterOffers", fields: [parentOfferId], references: [id], onDelete: SetNull)
  counterOffers         Offer[]           @relation("CounterOffers")
  counterOffersList     CounterOffer[]    @relation("OfferCounterOffers")
  offerHistory          OfferHistory[]
  offerNotifications    OfferNotification[]
  sellerPayment        Payment?          @relation("OfferSellerPayment", fields: [sellerPaymentId], references: [id], onDelete: SetNull)
  buyerPayment         Payment?          @relation("OfferBuyerPayment", fields: [buyerPaymentId], references: [id], onDelete: SetNull)
  logistics            Logistics[]

  @@map("offers")
}

model CounterOffer {
  id                   String           @id @default(cuid())
  offerId              String
  fromId               String
  requirementId        String
  counterofferNumber   Int              // 1, 2, 3, 4, 5 (max 5)
  offeredPrice         Decimal          @db.Decimal(10, 2)
  offeredQuantity      String
  status               CounterOfferStatus @default(PENDING)
  negotiationWindowHours Int            // Hours from requirement
  expiresAt            DateTime
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Relations
  offer                Offer            @relation("OfferCounterOffers", fields: [offerId], references: [id], onDelete: Cascade)
  fromUser             User             @relation("UserCounterOffers", fields: [fromId], references: [id], onDelete: Cascade)
  requirement          Requirement      @relation("RequirementCounterOffers", fields: [requirementId], references: [id], onDelete: Cascade)

  @@map("counter_offers")
}

enum CounterOfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model OfferHistory {
  id          String         @id @default(cuid())
  offerId     String
  action      OfferAction
  performedBy String
  performedAt DateTime       @default(now())
  notes       String?        @db.Text
  oldValues   Json?
  newValues   Json?

  // Relations
  offer       Offer          @relation(fields: [offerId], references: [id], onDelete: Cascade)
  performer   User           @relation("UserOfferHistory", fields: [performedBy], references: [id], onDelete: Cascade)

  @@map("offer_history")
}

model OfferNotification {
  id               String             @id @default(cuid())
  offerId          String
  recipientId      String
  notificationType OfferNotificationType
  isRead           Boolean            @default(false)
  createdAt        DateTime           @default(now())

  // Relations
  offer            Offer              @relation(fields: [offerId], references: [id], onDelete: Cascade)
  recipient        User               @relation("UserOfferNotifications", fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("offer_notifications")
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
  WITHDRAWN
  COUNTERED
}

enum OfferAction {
  CREATED
  UPDATED
  ACCEPTED
  REJECTED
  EXPIRED
  WITHDRAWN
  COUNTERED
}

enum OfferNotificationType {
  NEW_OFFER
  OFFER_ACCEPTED
  OFFER_REJECTED
  OFFER_EXPIRED
  COUNTER_OFFER
}

enum OfferPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum UnitType {
  LITERS
  KILOGRAMS
  TONS
  PIECES
  CARTONS
  DRUMS
  BARRELS
  CUBIC_METERS
  SQUARE_METERS
  METERS
  FEET
  INCHES
  GALLONS
  POUNDS
  OUNCES
  GRAMS
  MILLILITERS
  CUBIC_FEET
  SQUARE_FEET
  YARDS
  CUSTOM
}

enum AdminRole {
  SUPER_ADMIN
  COMPLIANCE
  MODERATOR
  FINANCE
  CMS_EDITOR
  SUPPORT
}

model Payment {
  id                String        @id @default(cuid())
  offerId           String?       // Optional - can be used for other payment types
  bidId             String?       // Optional - for bid-related payments
  userId            String        // User making the payment
  paymentType       PaymentType
  amount            Decimal       @db.Decimal(10, 2)
  currency          String        @default("INR")
  paymentMethod     PaymentMethod
  paymentStatus     PaymentStatus @default(PENDING)
  transactionId     String?       // External payment gateway transaction ID
  gatewayResponse   Json?         // Store gateway response data
  utrNumber         String?       // UTR number for bank transfers
  paymentScreenshot String?       // Screenshot of payment proof
  notes             String?       @db.Text
  processedAt       DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  bid               Bid?          @relation("BidPayments", fields: [bidId], references: [id], onDelete: SetNull)
  sellerOffers      Offer[]       @relation("OfferSellerPayment")
  buyerOffers       Offer[]       @relation("OfferBuyerPayment")
  sellerBids        Bid[]         @relation("BidSellerPayment")
  buyerBids         Bid[]         @relation("BidBuyerPayment")

  @@map("payments")
}

model Logistics {
  id                String           @id @default(cuid())
  offerId           String?          // Optional - can be used for offer-related logistics
  bidId             String?           // Optional - for bid-related logistics
  userId            String            // User who created the logistics entry
  driverName        String?
  driverPhone       String?
  truckNumber       String?
  truckType         String?
  logisticsCompany  String?
  companyPhone      String?
  companyEmail      String?
  pickupAddress     String?           @db.Text
  deliveryAddress   String?           @db.Text
  estimatedPickupDate   DateTime?
  estimatedDeliveryDate DateTime?
  actualPickupDate     DateTime?
  actualDeliveryDate   DateTime?
  status            LogisticsStatus   @default(PENDING)
  notes             String?           @db.Text
  trackingNumber    String?
  // New fields
  invoiceCopy       String?           // File path for invoice copy
  biltyCopy         String?           // File path for bilty copy
  insurance         Boolean?          // Insurance yes/no
  trackingId        String?           // Any tracking ID
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  offer             Offer?            @relation(fields: [offerId], references: [id], onDelete: SetNull)
  bid               Bid?              @relation("BidLogistics", fields: [bidId], references: [id], onDelete: SetNull)
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("logistics")
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum PaymentType {
  COMMISSION
  COMPLETE_PAYMENT
  REFUND
  ADVANCE_PAYMENT
}

enum PaymentMethod {
  UPI
  CARD
  NET_BANKING
  WALLET
  BANK_TRANSFER
}

enum LogisticsStatus {
  PENDING
  SCHEDULED
  IN_TRANSIT
  DELIVERED
  CANCELLED
}

model Upload {
  id          String   @id @default(cuid())
  filename    String
  originalName String
  mimeType    String
  size        Int
  path        String
  url         String
  uploadedBy  String
  uploadedAt  DateTime @default(now())
  description String?
  tags        String[] @default([])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("uploads")
}
